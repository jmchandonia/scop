/*
 * Software to build and maintain SCOPe, https://scop.berkeley.edu/
 *
 * Copyright (C) 2012-2018 The Regents of the University of California
 *
 * For feedback, mailto:scope@compbio.berkeley.edu
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * Version 2.1 of the License, or (at your option) any later version.
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301
 * USA
 */
package gov.lbl.scop.app;

import java.sql.*;
import java.io.*;
import java.util.*;
import java.util.regex.*;
import org.strbio.io.*;
import org.strbio.math.*;
import org.strbio.mol.*;
import org.strbio.util.*;
import org.strbio.IO;
import gov.lbl.scop.local.LocalSQL;

/**
   Fill in SCOP node table from master file.

   Handles merge format correctly for import, by making history entries
*/
public class ParseMasterFile {
    final public static void main(String argv[]) {
        try {
            LocalSQL.connectRW();
            Statement stmt = LocalSQL.createStatement();
            Statement stmt2 = LocalSQL.createStatement();
            ResultSet rs;
            int action = 0;

            boolean ignoreChainCase = false;  // only needed prior to 1.75

            if (argv.length != 3)
                throw new Exception("syntax: ParseMasterFile release master_file action");

            int scopReleaseID = LocalSQL.lookupSCOPRelease(argv[0]);
            if (scopReleaseID==0)
                throw new Exception("no such version "+argv[0]);

            if (argv[2].equals("import"))
                action = 1;
            else if (argv[2].equals("comments"))
                action = 2;
            else if (argv[2].equals("links"))
                action = 3;

            if (action==0)
                throw new Exception("specify action:  import, comments, or links");

            rs = stmt.executeQuery("select is_public from scop_release where id="+scopReleaseID);
            rs.next();
            boolean isPublic = (rs.getInt(1)==1);
            if ((isPublic) && (action==1))
                throw new Exception("can't load masterfile for public release");

            rs = stmt.executeQuery("select max(id) from scop_release");
            rs.next();
            int maxID = rs.getInt(1);
            if ((scopReleaseID != maxID) && (action==1))
                throw new Exception("can't load masterfile for previous release");
            int oldScopID = scopReleaseID-1;  // must be consecutive

            // delete old nodes for this release
            if (action==1) {
                stmt.executeUpdate("delete from link_species where node_id in (select id from scop_node where release_id="+scopReleaseID+")");
                stmt.executeUpdate("delete from link_pfam where node_id in (select id from scop_node where release_id="+scopReleaseID+")");
                stmt.executeUpdate("delete from link_uniprot where node_id in (select id from scop_node where release_id="+scopReleaseID+")");
                stmt.executeUpdate("delete from link_pubmed where node_id in (select id from scop_node where release_id="+scopReleaseID+")");
                stmt.executeUpdate("delete from link_pdb where node_id in (select id from scop_node where release_id="+scopReleaseID+")");
                stmt.executeUpdate("delete from scop_comment where node_id in (select id from scop_node where release_id="+scopReleaseID+")");
                stmt.executeUpdate("delete from scop_history where release_id="+scopReleaseID);
                stmt.executeUpdate("set FOREIGN_KEY_CHECKS=0");
                stmt.executeUpdate("delete from scop_node where release_id="+scopReleaseID);
                stmt.executeUpdate("set FOREIGN_KEY_CHECKS=1");
            }
            else if (action==2) {
                // set all comments to auto
                stmt.executeUpdate("update scop_comment set is_autogenerated=1 where node_id in (select id from scop_node where release_id="+scopReleaseID+")");
            }

            // how many types of levels are there?
            Vector<String> levels = new Vector<String>();
            rs = stmt.executeQuery("select master_abbreviation from scop_level order by id");
            while (rs.next())
                levels.add(rs.getString(1));
            int[] parentID = new int[levels.size()];  // parents of current node at each level in scop_level
	    
            // create root node for this release
            if (action==1)
                // always same parent at root level
                parentID[0] = LocalSQL.createNode(0,
                                                  null,
                                                  null,
                                                  "SCOP root",
                                                  1,
                                                  0,
                                                  scopReleaseID,
                                                  1);
            else
                parentID[0] = LocalSQL.lookupNodeBySunid(0,scopReleaseID);

            // finally, load master file
            BufferedReader infile = IO.openReader(argv[1]);
            String buffer;
            // node id(s) from last line
            Vector<Integer> lastNodeIDs = new Vector<Integer>();
            int lastLevelID = 1;
            boolean propogateDescription = false;
            Pattern consecutiveWS = Pattern.compile("\\s\\s");
            while ((buffer=infile.readLine()) != null) {
                // handle non-parseable comments
                if (buffer.startsWith("#"))
                    continue;

                // turn tabs to spaces
                if (buffer.indexOf('\t')>-1)
                    buffer = buffer.replace('\t',' ');

                // turn consecutive whitespace into one
                Matcher m = consecutiveWS.matcher(buffer);
                if (m.matches())
                    buffer = buffer.replaceAll("\\s+"," ");

                // handle comments meant for users
                if (buffer.startsWith("!")) {
                    String comment = buffer.substring(1).trim();

                    if ((action==1) || (action==2) || (action==3)) {
                        // special handling of Pfam links
                        if (comment.indexOf("Pfam ") > -1)
                            for (Integer id : lastNodeIDs)
                                ParseDirCom.linkPfam(id.intValue(),
                                                     comment);
                        if (comment.indexOf("PfamB ") > -1)
                            for (Integer id : lastNodeIDs)
                                ParseDirCom.linkPfamB(id.intValue(),
                                                      comment);

                        // special handling of Uniprot links
                        if (comment.indexOf("SQ ") > -1)
                            for (Integer id : lastNodeIDs)
                                ParseDirCom.linkUniprot(id.intValue(),
                                                        comment);
                        // special handling of PubMed links
                        if (comment.indexOf("PubMed ") > -1)
                            for (Integer id : lastNodeIDs)
                                ParseDirCom.linkPubMed(id.intValue(),
                                                       comment);
                    }

                    // skip comments that are just links to superfamily
                    if (comment.indexOf("http://supfam.mrc-lmb.cam.ac.uk/SUPERFAMILY") > -1)
                        continue;
		    

                    // filter out links
                    if (comment.indexOf("http://")>-1)
                        comment = HTML.stripHTML(comment);

                    if (action==1) {
                        // comments in master file are not automatic
                        for (Integer id : lastNodeIDs) {
                            stmt.executeUpdate("insert into scop_comment values (null,"+
                                               id+", \""+
                                               StringUtil.replace(comment,"\"","\\\"")+"\", 0)");
                            if (comment.startsWith("automatically matched to "))
                                stmt.executeUpdate("update scop_node set curation_type_id=2 where id="+id);
                            else if (comment.startsWith("automated match to "))
                                stmt.executeUpdate("update scop_node set curation_type_id=3 where id="+id);

                        }
                    }
                    else if (action==2) {
                        for (Integer id : lastNodeIDs) {
                            rs = stmt.executeQuery("select id from scop_comment where node_id="+id+" and description=\""+StringUtil.replace(comment,"\"","\\\"")+"\"");
                            int commentID = 0;
                            while (rs.next()) {
                                commentID = rs.getInt(1);
                                stmt2.executeUpdate("update scop_comment set is_autogenerated=0 where id="+commentID);
                            }
                            if (commentID==0) {
                                stmt.executeUpdate("insert into scop_comment values (null,"+
                                                   id+", \""+
                                                   StringUtil.replace(comment,"\"","\\\"")+"\", 0)");
                            }
                        }
                    }
                    continue;
                }

                // skip blank lines
                buffer = buffer.trim();
                if (buffer.length()<2)
                    continue;

                if (buffer.startsWith("END"))
                    System.exit(0);

                // other scop levels:
                String level = buffer.substring(0,2);
                int levelID = levels.indexOf(level)+1;
                if (levelID==0)
                    throw new Exception("unknown line "+buffer);

                // make sure we know parent
                int parentNode = parentID[levelID-2];
                if (parentNode == 0)
                    throw new Exception("unknown parent for "+buffer);

                // clear all children
                for (int i=levelID-1; i<levels.size(); i++)
                    parentID[i] = 0;

                // save old sunids
                String sunids = null;
                int pos = buffer.indexOf("#$");
                if (pos > -1) {
                    sunids = buffer.substring(pos+2).trim();
                    buffer = buffer.substring(2,pos).trim();
                }
                else
                    buffer = buffer.substring(2).trim();

                if (buffer.indexOf("http://")>-1)
                    buffer = HTML.stripHTML(buffer);

                // hacks for mf format weirdness
                if (levelID==2) {
                    pos = buffer.indexOf(" [");
                    if (pos > -1)
                        buffer = buffer.substring(0,pos);
                }
                else if (levelID==3) {
                    pos = buffer.lastIndexOf(" cl ");
                    if (pos > -1)
                        buffer = buffer.substring(0,pos);
                    else if (buffer.startsWith("cl "))
                        buffer = "";
                }

                if (levelID==8) {  // may be more than one node per "ID" line
                    lastNodeIDs.clear();
		    
                    String code = buffer.substring(0,4).toLowerCase();

                    int idType = 0;
                    if (buffer.length() > 7) {
                        String rech = buffer.substring(5,7);
                        if (rech.equals("CH"))
                            idType = 1;
                        else if (rech.equals("RE"))
                            idType = 2;
                    }
		    
                    int pdbEntryID = LocalSQL.lookupPDB(code);
                    if (pdbEntryID==0)
                        throw new Exception("error - PDB code not found for "+buffer);

                    if (idType == 0) {
                        // only 1 domain, with chain id of ' '
                        String domain = code + " -";
                        int sunid = 0;
                        int[] merged = null;
                        if (sunids!=null) {
                            if (sunids.indexOf(" ") > -1)
                                throw new Exception("invalid sunids in "+buffer);
                            if (sunids.indexOf("+") > -1) {
                                String[] s = sunids.split("+");
                                merged = new int[s.length];
                                for (int i=0; i<merged.length; i++)
                                    merged[i] = StringUtil.atoi(s[i]);
                            }
                            else
                                sunid = StringUtil.atoi(sunids);
                        }
                        int lastNodeID = 0;
                        if (action==1) {
                            lastNodeID = LocalSQL.createNode(sunid,
                                                             null,
                                                             null,
                                                             domain,
                                                             levelID,
                                                             parentNode,
                                                             scopReleaseID,
                                                             0);
                            if (merged != null) {
                                for (int i=0; i<merged.length; i++) {
                                    int oldID = LocalSQL.lookupNodeBySunid(merged[i],
                                                                           scopReleaseID-1);
                                    if (oldID==0)
                                        throw new Exception("invalid merge sunid "+merged[i]);
                                    stmt.executeUpdate("insert into scop_history values (null, "+oldID+", "+lastNodeID+", "+scopReleaseID+", 4, null)");
                                }
                            }
                        }
                        else
                            lastNodeID = LocalSQL.lookupNodeBySunid(sunid,
                                                                    scopReleaseID);
                        lastNodeIDs.add(new Integer(lastNodeID));

                        int pdbChainID = 0;
                        rs = stmt.executeQuery("select c.id from pdb_chain c, raf, pdb_release r where c.id=raf.pdb_chain_id and raf.first_release_id<="+scopReleaseID+" and raf.last_release_id >= "+scopReleaseID+" and c.pdb_release_id=r.id and r.pdb_entry_id="+pdbEntryID+" and c.chain=\" \"");
                        if (rs.next()) {
                            pdbChainID = rs.getInt(1);
                            rs.close();
                        }
                        else {
                            rs.close();
                            int releaseID = FreezeRAF.findPDBRelease(pdbEntryID, scopReleaseID);
                            if (releaseID==0) {
                                // special cases, like lit refs, don't have local xml files
                                rs = stmt.executeQuery("select r.id from pdb_release r, scop_release s where r.pdb_entry_id="+pdbEntryID+" and r.revision_date<=s.freeze_date and s.id="+scopReleaseID+" order by r.revision_date desc, r.file_date desc limit 1");
                                rs.next();
                                releaseID = rs.getInt(1);
                                rs.close();
                            }
                            pdbChainID = MakeNewRAF.lookupChain(releaseID,' ');
                        }
                        if (pdbChainID==0)
                            throw new IOException("error: chain missing in "+domain);
                        if (action==1) {
                            stmt.executeUpdate("insert into link_pdb values ("+
                                               lastNodeID+", "+
                                               pdbChainID+")");
                        }
                    }
                    else {  // RE or CH
                        String[] domains = buffer.substring(8).split(";");
                        String[] sunid2 = null;
                        if (sunids != null)
                            sunid2 = sunids.split(" ");
                        for (int i=0; i<domains.length; i++) {
                            String domain = domains[i];
                            int sunid = 0;
                            int[] merged = null;
                            if ((sunids != null) &&
                                (i < sunid2.length)) {
                                if (sunid2[i].indexOf("+") > -1) {
                                    String[] s = sunid2[i].split("+");
                                    merged = new int[s.length];
                                    for (int j=0; j<merged.length; j++)
                                        merged[j] = StringUtil.atoi(s[j]);
                                }
                                else
                                    sunid = StringUtil.atoi(sunid2[i]);
                            }

                            // parse out list of chains
                            HashSet<Character> chains = new HashSet<Character>();
                            if (idType==1) { // CH
                                chains.add(domain.charAt(0));
                                pos = domain.indexOf(',');
                                while (pos > -1) {
                                    chains.add(domain.charAt(pos+1));
                                    pos = domain.indexOf(',',pos+1);
                                }
                            }
                            else { // RE
                                pos = domain.indexOf(':');
                                if (pos == -1) {
                                    chains.add(' ');
                                }
                                else {
                                    while (pos > -1) {
                                        char chain = domain.charAt(pos-1);
                                        chains.add(new Character(chain));
                                        pos = domain.indexOf(':',pos+1);
                                    }
                                }
                            }

                            if (idType==1) // CH
                                domain = code + " " + StringUtil.replace(domain,",",":,")+":";
                            else // RE
                                domain = code + " " + domain;
                            domain = StringUtil.replace(domain,"\"","\\\"");

                            int lastNodeID = 0;
                            if (action==1) {
                                lastNodeID = LocalSQL.createNode(sunid,
                                                                 null,
                                                                 null,
                                                                 domain,
                                                                 levelID,
                                                                 parentNode,
                                                                 scopReleaseID,
                                                                 0);
                                if (merged != null) {
                                    for (int j=0; j<merged.length; j++) {
                                        int oldID = LocalSQL.lookupNodeBySunid(merged[j],
                                                                               scopReleaseID-1);
                                        if (oldID==0)
                                            throw new Exception("invalid merge sunid "+merged[j]);
                                        stmt.executeUpdate("insert into scop_history values (null, "+oldID+", "+lastNodeID+", "+scopReleaseID+", 4, null)");
                                    }
                                }
                            }
                            else
                                lastNodeID = LocalSQL.lookupNodeBySunid(sunid,
                                                                        scopReleaseID);
                            lastNodeIDs.add(new Integer(lastNodeID));

                            // add pdb links to each chain
                            for (Character c : chains) {
                                char chain = c.charValue();
                                int pdbChainID = 0;
                                rs = stmt.executeQuery("select c.id from pdb_chain c, raf, pdb_release r where c.id=raf.pdb_chain_id and raf.first_release_id<="+scopReleaseID+" and raf.last_release_id >= "+scopReleaseID+" and c.pdb_release_id=r.id and r.pdb_entry_id="+pdbEntryID+" and c.chain=\""+chain+"\"");
                                if (rs.next()) {
                                    pdbChainID = rs.getInt(1);
                                    rs.close();
                                }
                                else if (ignoreChainCase) {
                                    rs.close();
                                    rs = stmt.executeQuery("select c.id from pdb_chain c, raf, pdb_release r where c.id=raf.pdb_chain_id and raf.first_release_id<="+scopReleaseID+" and raf.last_release_id >= "+scopReleaseID+" and c.pdb_release_id=r.id and r.pdb_entry_id="+pdbEntryID+" and upper(c.chain)=\""+chain+"\"");
                                    if (rs.next()) {
                                        pdbChainID = rs.getInt(1);
                                        rs.close();

                                        // also need to make description lower case
                                        if (action==1)
                                            stmt.executeUpdate("update scop_node set description = lower(description) where id="+lastNodeID);
                                    }
                                    else
                                        rs.close();
                                }
                                else {
                                    rs.close();
                                    int releaseID = FreezeRAF.findPDBRelease(pdbEntryID, scopReleaseID);
                                    if (releaseID==0) {
                                        // special cases, like lit refs, don't have local xml files
                                        rs = stmt.executeQuery("select r.id from pdb_release r, scop_release s where r.pdb_entry_id="+pdbEntryID+" and r.revision_date<=s.freeze_date and s.id="+scopReleaseID+" order by r.revision_date desc, r.file_date desc limit 1");
                                        rs.next();
                                        releaseID = rs.getInt(1);
                                        rs.close();
                                    }
                                    pdbChainID = MakeNewRAF.lookupChain(releaseID,chain);
                                }
                                if (pdbChainID==0)
                                    throw new IOException("error: chain missing in "+domain);

                                if ((action==1) || (action==3)) {
                                    rs = stmt.executeQuery("select node_id from link_pdb where node_id="+lastNodeID+" and pdb_chain_id="+pdbChainID);
                                    if (!rs.next()) {
                                        rs.close();
                                        stmt.executeUpdate("insert into link_pdb values ("+
                                                           lastNodeID+", "+
                                                           pdbChainID+")");
                                    }
                                    else
                                        rs.close();
                                }
                            }
                        }
                    }
                }
                else { // levels besides ID
                    lastNodeIDs.clear();
                    int sunid = 0;
                    int[] merged = null;
                    if (sunids!=null) {
                        if (sunids.indexOf(" ") > -1)
                            throw new Exception("invalid sunids in "+buffer);
                        if (sunids.indexOf("+") > -1) {
                            String[] s = sunids.split("+");
                            merged = new int[s.length];
                            for (int i=0; i<merged.length; i++)
                                merged[i] = StringUtil.atoi(s[i]);
                        }
                        else
                            sunid = StringUtil.atoi(sunids);
                    }
                    buffer = StringUtil.replace(buffer,"\"","\\\"");
                    int lastNodeID = 0;
                    if (action==1) {
                        lastNodeID = LocalSQL.createNode(sunid,
                                                         null,
                                                         null,
                                                         buffer,
                                                         levelID,
                                                         parentNode,
                                                         scopReleaseID,
                                                         0);
                        if (merged != null) {
                            for (int i=0; i<merged.length; i++) {
                                int oldID = LocalSQL.lookupNodeBySunid(merged[i],
                                                                       scopReleaseID-1);
                                if (oldID==0)
                                    throw new Exception("invalid merge sunid "+merged[i]);
                                stmt.executeUpdate("insert into scop_history values (null, "+oldID+", "+lastNodeID+", "+scopReleaseID+", 4, null)");
                            }
                        }
                    }
                    else
                        lastNodeID = LocalSQL.lookupNodeBySunid(sunid,
                                                                scopReleaseID);
                    lastNodeIDs.add(new Integer(lastNodeID));
                    parentID[levelID-1] = lastNodeID;

                    // create species node if level 7
                    if (levelID==7) {
                        if ((action==1) || (action==3))
                            MakeSpecies.processNode(lastNodeID,
                                                    StringUtil.replace(buffer,"\\\"","\""));
                    }

                    // propogate description upwards to blank parents
                    if ((action==1) && (propogateDescription) && (buffer.length() > 0)) {
                        if (levelID==7)
                            throw new Exception("can't propogate species description");
                        for (int i=2; i<levelID-1; i++)
                            stmt.executeUpdate("update scop_node set description=\""+buffer+"\" where id="+parentID[i]+" and length(description)=0");

                        propogateDescription = false;
                    }

                    if (buffer.length()==0)
                        propogateDescription = true;
                }
            }

            // link all pdb species for this release
            if ((action==1) || (action==3)) {
                rs = stmt.executeQuery("select distinct(species_id) from link_species where node_id in (select id from scop_node where release_id="+scopReleaseID+" and level_id=7)");
                while (rs.next())
                    MakeSpecies.linkPDBSpecies(rs.getInt(1));
                rs.close();
            }
        }
        catch (Exception e) {
            System.out.println("Exception: "+e.getMessage());
            e.printStackTrace();
        }
    }
}
