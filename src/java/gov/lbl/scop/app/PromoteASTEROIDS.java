/*
 * Software to build and maintain SCOPe, https://scop.berkeley.edu/
 *
 * Copyright (C) 2012-2018 The Regents of the University of California
 *
 * For feedback, mailto:scope@compbio.berkeley.edu
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * Version 2.1 of the License, or (at your option) any later version.
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301
 * USA
 */
package gov.lbl.scop.app;

import gov.lbl.scop.local.*;
import gov.lbl.scop.util.*;
import gov.lbl.scop.util.annotation.*;
import org.strbio.util.*;

import java.sql.*;
import java.util.*;

/**
   Promote ASTEROIDS that pass all tests to SCOP domains in the
   new release.
   Replace previously autogenerated domains.

   Set "species" according to pdb source.
   Set "protein" according to pdb source or 99% identity
   Set "family" by %ID:  >=55% -> same family, <55% -> autoassigned
   unless pdb source protein matches.
*/
public class PromoteASTEROIDS {
    /**
       return latest gene annotation for a PDB chain, or null
       if there is none
    */
    final public static String getGene(int pdbChainID) throws Exception {
        String rv = null;
        Statement stmt = LocalSQL.createStatement();
        ResultSet rs = stmt.executeQuery("select g.gene_name from pdb_gene g, pdb_chain_gene pcs, pdb_release pr1, pdb_release pr2, pdb_chain pc1, pdb_chain pc2 where pr1.pdb_entry_id=pr2.pdb_entry_id and pc2.pdb_release_id=pr2.id and pc2.id=pcs.pdb_chain_id and pcs.pdb_gene_id=g.id and pc1.pdb_release_id=pr1.id and pc1.id="+pdbChainID+" and pc1.chain=pc2.chain order by pr2.revision_date desc limit 1");
        if (rs.next())
            rv = rs.getString(1);
        rs.close();
        stmt.close();
        return rv;
    }

    /**
       return latest species (scientific_name) annotation for a PDB
       chain, or null if there is none
    */
    final public static String getSpecies(int pdbChainID) throws Exception {
        String rv = null;
        Statement stmt = LocalSQL.createStatement();
        ResultSet rs = stmt.executeQuery("select s.scientific_name from pdb_source s, pdb_chain_source pcs, pdb_release pr1, pdb_release pr2, pdb_chain pc1, pdb_chain pc2 where pr1.pdb_entry_id=pr2.pdb_entry_id and pc2.pdb_release_id=pr2.id and pc2.id=pcs.pdb_chain_id and pcs.pdb_source_id=s.id and pc1.pdb_release_id=pr1.id and pc1.id="+pdbChainID+" and pc1.chain=pc2.chain order by pr2.revision_date desc limit 1");
        if (rs.next())
            rv = rs.getString(1);
        rs.close();
        stmt.close();
        return rv;
    }
    
    /**
       return latest taxid annotation for a PDB
       chain, or 0 if there is none
    */
    final public static int getTaxid(int pdbChainID) throws Exception {
        int rv = 0;
        Statement stmt = LocalSQL.createStatement();
        ResultSet rs = stmt.executeQuery("select s.ncbi_taxid from pdb_source s, pdb_chain_source pcs, pdb_release pr1, pdb_release pr2, pdb_chain pc1, pdb_chain pc2 where pr1.pdb_entry_id=pr2.pdb_entry_id and pc2.pdb_release_id=pr2.id and pc2.id=pcs.pdb_chain_id and pcs.pdb_source_id=s.id and pc1.pdb_release_id=pr1.id and pc1.id="+pdbChainID+" and pc1.chain=pc2.chain order by pr2.revision_date desc limit 1");
        if (rs.next())
            rv = rs.getInt(1);
        rs.close();
        stmt.close();
        return rv;
    }
    
    /**
       Promote ASTEROIDS to SCOP domains, if they pass all filters

       filterLevel is bitmap of:
       0 = evaluate all ASTEROIDS based on BLAST hits
       1 = all of chain or none
       2 = require at most 10-residue overhang with match
       4 = require same number of regions in hit
       8 = require only one domain per chain
       16 = change full-chain hits to cover whole chain
       32 = remove low res, synthetic, different length sequences
       64 = all of hit chain or none

       returns vector of new node ids if successful, or null if not.
       The last element of the vector will be the id of the promoted
       asteroid itself, and preceding elements will be the ids of its parents.
    */
    final public static Vector<Integer> promoteASTEROID(int asteroidID,
                                                        int pdbChainID,
                                                        int filterLevel,
                                                        boolean debug,
                                                        boolean assignSunids,
                                                        int annotationMethod)
        throws Exception {

        Statement stmt = LocalSQL.createStatement();

        ResultSet rs = stmt.executeQuery("select max(id) from scop_release");
        rs.next();
        int scopMaxReleaseID = rs.getInt(1);
        rs.close();

        rs = stmt.executeQuery("select a.chain_id, a.sid, a.header, a.description, a.scop_release_id, a.pfam_release_id, a.blast_hit_id, length(s.seq), s.is_reject from asteroid a, astral_seq s where a.seq_id=s.id and a.id="+asteroidID);
        rs.next();
        int astralChainID = rs.getInt(1);
        String sid = rs.getString(2);
        String header = rs.getString(3);
        String description = rs.getString(4);
        int scopReleaseID = rs.getInt(5);
        int pfamReleaseID = rs.getInt(6);
        int hitID = rs.getInt(7);
        int seqLength = rs.getInt(8);
        boolean isReject = (rs.getInt(9)==1);
        rs.close();

        if (!CheckASTEROIDS.passesFilter(asteroidID,
                                         filterLevel)) {
            if (debug)
                System.out.println("rejecting due to failed filter");
            return null;
        }

        if (description == null) {
            if (debug)
                System.out.println("rejecting due to null description");
            stmt.close();
            return null;
        }

        // these variables will be assigned values based on the type of ASTEROID row
        int hitNode;
        String hitSid = "";
        double hitPctID;

        if (header.contains(ASTEROIDS.Annotation.sourceToString(ASTEROIDS.Annotation.Source.SCOPSEQMATCH))) {
            hitSid = ASTEROIDS.Annotation.getSidFromHeaderString(header);
            hitNode = CommonSCOPQueries.getScopNodeBySidAndReleaseID(hitSid, scopReleaseID);
            hitPctID = 100;
        }
        else {
            // get blast hit details
            rs = stmt.executeQuery("select n.id, n.sid, b.pct_identical from astral_seq_blast b, astral_domain d, scop_node n, astral_seq s where n.id=d.node_id and d.seq_id=s.id and s.id=b.seq2_id and b.id="+hitID+" and b.source_id=d.source_id and b.style1_id=1 and (b.style2_id=d.style_id or d.style_id=1) and b.release_id=n.release_id");
            if (!rs.next()) {
                if (debug)
                    System.out.println("rejecting due to no blast hit");
                rs.close();
                stmt.close();
                return null;
            }
            hitNode = rs.getInt(1);
            hitSid = rs.getString(2);
            hitPctID = rs.getDouble(3);
            rs.close();
        }

        // skip if hit is to a genetic domain
        if (hitSid.indexOf('.') > -1) {
            if (debug)
                System.out.println("rejecting due to genetic domain");
            stmt.close();
            return null;
        }

        // find PDB chain id, RAF for this chain
        // rs = stmt.executeQuery("select c.id, r.line from pdb_chain c, raf r, astral_chain ac where c.id=r.pdb_chain_id and r.id=ac.raf_id and ac.id="+astralChainID);
        rs = stmt.executeQuery("select line from raf where pdb_chain_id="+pdbChainID);
        if (!rs.next()) {
            if (debug)
                System.out.println("rejecting due to lack of PDB chain");
            rs.close();
            stmt.close();
            return null;
        }
        // int pdbChainID = rs.getInt(1);
        String rafLine = rs.getString(1);
        rs.close();

        // parse description into an Annotation
        ASTEROIDS.Annotation a = new ASTEROIDS.Annotation();
        a.parseHeaderRegions(description,
                             rafLine);

        if ((filterLevel/16) % 2 == 1) {
            // expand description until (near) ends  (only applies to domains in single-domain chains)
            boolean singleDomainChain=true;
            rs = stmt.executeQuery("select id from asteroid where chain_id="+astralChainID+" and scop_release_id="+scopReleaseID+" and pfam_release_id="+pfamReleaseID+" and id != "+asteroidID+" limit 1");
            if (rs.next()) {
                singleDomainChain=false;
            }
            rs.close();
            if (singleDomainChain) {
                a.expandToNearEnds(rafLine);
                description = a.getHeaderRegions(rafLine);
            }
        }

        // get annotated species and protein for this PDB chain
        String pdbGene = getGene(pdbChainID);
        if (debug)
            System.out.println("PDB gene found as "+pdbGene);
        String pdbSpecies = getSpecies(pdbChainID);
        if (pdbSpecies==null) {
            if (debug)
                System.out.println("rejecting due to lack of species");
            stmt.close();
            return null;
        }
        if (pdbSpecies.trim().indexOf(' ')==-1) {
            if (debug)
                System.out.println("rejecting due to lack of specific species");
            stmt.close();
            return null;
        }
        if (debug)
            System.out.println("PDB species found as "+pdbSpecies);
        int pdbTaxid = getTaxid(pdbChainID);
        if (debug)
            System.out.println("PDB taxid found as "+pdbTaxid);

        Vector<Integer> rv = new Vector<Integer>();

        // Node is good!  figure out its parents in new hierarchy:

        // sf level:
        int oldParentSFID = LocalSQL.findParent(hitNode,4);
        int oldParentSunid = LocalSQL.getSunid(oldParentSFID);
        if (oldParentSunid == -1)
            throw new Exception("Error finding old sunid for node "+hitNode);
        int newParentID = LocalSQL.lookupNodeBySunid(oldParentSunid,
                                                     scopMaxReleaseID);
        String newSCCS = LocalSQL.getSCCS(newParentID);
        if (newParentID == 0)
            throw new Exception("Error finding new sunid for node "+hitNode);

        // family level
        boolean sameFamily = true;
        int oldParentID = LocalSQL.findParent(hitNode,5);
        if (debug)
            System.out.println("Family: hit pct id is "+hitPctID);
        if (hitPctID < 55.0) {
            sameFamily = false;
            // exception:  the same protein is found in this family,
            // and not in other families in the same superfamily
            if (pdbGene != null) {
                rs = stmt.executeQuery("select n1.id from pdb_gene g, pdb_chain_gene pcs, pdb_release pr1, pdb_release pr2, pdb_chain pc1, pdb_chain pc2, link_pdb l, scop_node n1, scop_node n2, scop_node n3 where pr1.pdb_entry_id=pr2.pdb_entry_id and pc2.pdb_release_id=pr2.id and pc2.id=pcs.pdb_chain_id and pcs.pdb_gene_id=g.id and pc1.pdb_release_id=pr1.id and l.pdb_chain_id=pc1.id and l.node_id=n1.id and n1.parent_node_id=n2.id and n2.parent_node_id=n3.id and n3.parent_node_id="+oldParentID+" and g.gene_name=\""+StringUtil.replace(pdbGene,"\"","\\\"")+"\" limit 1");
                if (rs.next()) {
                    if (debug)
                        System.out.println("Family: gene found in same family");
                    rs.close();
                    rs = stmt.executeQuery("select n1.id from pdb_gene g, pdb_chain_gene pcs, pdb_release pr1, pdb_release pr2, pdb_chain pc1, pdb_chain pc2, link_pdb l, scop_node n1, scop_node n2, scop_node n3, scop_node n4 where pr1.pdb_entry_id=pr2.pdb_entry_id and pc2.pdb_release_id=pr2.id and pc2.id=pcs.pdb_chain_id and pcs.pdb_gene_id=g.id and pc1.pdb_release_id=pr1.id and l.pdb_chain_id=pc1.id and l.node_id=n1.id and n1.parent_node_id=n2.id and n2.parent_node_id=n3.id and n3.parent_node_id=n4.id and n4.parent_node_id="+oldParentSFID+" and n4.id != "+oldParentID+" and g.gene_name=\""+StringUtil.replace(pdbGene,"\"","\\\"")+"\" limit 1");
                    if (!rs.next()) {
                        sameFamily = true;
                        if (debug)
                            System.out.println("Family: gene NOT found in other families in same SF");
                    }
                    else {
                        if (debug)
                            System.out.println("Family: gene found in other families in same SF - "+rs.getInt(1));
                    }
                }
                else {
                    if (debug)
                        System.out.println("Family: gene NOT found in same family");
                }
                rs.close();
            }
        }
        if (sameFamily) {
            if (debug)
                System.out.println("Family: assigned to same family");
            oldParentSunid = LocalSQL.getSunid(oldParentID);
            if (oldParentSunid == -1)
                throw new Exception("Error finding old sunid for node "+hitNode);
            newParentID = LocalSQL.lookupNodeBySunid(oldParentSunid,
                                                     scopMaxReleaseID);
            newSCCS = LocalSQL.getSCCS(newParentID);
            if (newParentID == 0)
                throw new Exception("Error finding new sunid for node "+hitNode);
        }
        else {
            if (debug)
                System.out.println("Family: assigned to automated family");
            newSCCS += ".0";
            // assign to automated family
            rs = stmt.executeQuery("select id from scop_node where parent_node_id="+newParentID+" and description=\"automated matches\" and sccs=\""+newSCCS+"\"");
            if (rs.next()) {
                newParentID = rs.getInt(1);
                rs.close();
            }
            else {
                rs.close();
                if (!debug) {
                    newParentID = LocalSQL.createNode((assignSunids ? LocalSQL.getNextSunid() : 0),
                                                      newSCCS,
                                                      null,
                                                      "automated matches",
                                                      5,
                                                      newParentID,
                                                      scopMaxReleaseID,
                                                      annotationMethod);
                    stmt.executeUpdate("insert into scop_comment values(null, "+newParentID+", \"not a true family\", 0)");
                    rv.add(new Integer(newParentID));
                }
            }
        }

        // protein level
        boolean sameProtein = sameFamily;
        oldParentID = LocalSQL.findParent(hitNode,6);
        if ((sameFamily) && (hitPctID < 99.0)) {
            // not same protein unless pdb gene matches a member
            // of this protein
            sameProtein = false;
            if (pdbGene != null) {
                rs = stmt.executeQuery("select n1.id from pdb_gene g, pdb_chain_gene pcs, pdb_release pr1, pdb_release pr2, pdb_chain pc1, pdb_chain pc2, link_pdb l, scop_node n1, scop_node n2 where pr1.pdb_entry_id=pr2.pdb_entry_id and pc2.pdb_release_id=pr2.id and pc2.id=pcs.pdb_chain_id and pcs.pdb_gene_id=g.id and pc1.pdb_release_id=pr1.id and l.pdb_chain_id=pc1.id and l.node_id=n1.id and n1.parent_node_id=n2.id and n2.parent_node_id="+oldParentID+" and g.gene_name=\""+StringUtil.replace(pdbGene,"\"","\\\"")+"\" limit 1");
                if (rs.next()) {
                    if (debug)
                        System.out.println("Protein: found same protein");
                    sameProtein = true;
                }
                else {
                    if (debug)
                        System.out.println("Protein: NOT found same protein");
                }
                rs.close();
            }
        }
        if (sameProtein) {
            if (debug)
                System.out.println("Protein: assigned to same protein");
            oldParentSunid = LocalSQL.getSunid(oldParentID);
            if (oldParentSunid == -1)
                throw new Exception("Error finding old sunid for node "+hitNode);
            newParentID = LocalSQL.lookupNodeBySunid(oldParentSunid,
                                                     scopMaxReleaseID);
            if (newParentID == 0)
                throw new Exception("Error finding new sunid for node "+hitNode);
        }
        else {
            if (debug)
                System.out.println("Protein: assigned to new protein");
            // assign to automated protein
            rs = stmt.executeQuery("select id from scop_node where parent_node_id="+newParentID+" and description=\"automated matches\" and sccs=\""+newSCCS+"\"");
            if (rs.next()) {
                newParentID = rs.getInt(1);
                rs.close();
            }
            else {
                rs.close();
                if (!debug) {
                    newParentID = LocalSQL.createNode((assignSunids ? LocalSQL.getNextSunid() : 0),
                                                      newSCCS,
                                                      null,
                                                      "automated matches",
                                                      6,
                                                      newParentID,
                                                      scopMaxReleaseID,
                                                      annotationMethod);
                    stmt.executeUpdate("insert into scop_comment values(null, "+newParentID+", \"not a true protein\", 0)");
                    rv.add(new Integer(newParentID));
                }
            }
        }

        // species level
        oldParentID = LocalSQL.findParent(hitNode,7);
        boolean sameSpecies = false;
        int speciesID = 0;
        if ((pdbSpecies != null) && (sameProtein)) {
            // check whether scop species matches
            rs = stmt.executeQuery("select s.id from species s, link_species l where l.node_id="+oldParentID+" and l.species_id=s.id and s.scientific_name=\""+StringUtil.replace(pdbSpecies,"\"","\\\"")+"\" limit 1");
            if (rs.next()) {
                sameSpecies = true;
                if (debug)
                    System.out.println("Species: found same species");
            }
            else {
                if (debug)
                    System.out.println("Species: NOT found same species");
            }
            rs.close();
	    
            if (!sameSpecies) {
                // also check for matching PDB species under parent protein
                rs = stmt.executeQuery("select n1.id from pdb_source s, pdb_chain_source pcs, pdb_release pr1, pdb_release pr2, pdb_chain pc1, pdb_chain pc2, link_pdb l, scop_node n1 where pr1.pdb_entry_id=pr2.pdb_entry_id and pc2.pdb_release_id=pr2.id and pc2.id=pcs.pdb_chain_id and pcs.pdb_source_id=s.id and pc1.pdb_release_id=pr1.id and l.pdb_chain_id=pc1.id and l.node_id=n1.id and n1.parent_node_id="+oldParentID+" and s.scientific_name=\""+StringUtil.replace(pdbSpecies,"\"","\\\"")+"\" limit 1");
                if (rs.next()) {
                    sameSpecies = true;
                    if (debug)
                        System.out.println("Species: found same species 2");
                }
                else {
                    if (debug)
                        System.out.println("Species: NOT found same species 2");
                }
                rs.close();
            }

            if ((!sameSpecies) && (pdbTaxid > 0)) {
                // also try lookup by taxid
                rs = stmt.executeQuery("select n1.id from pdb_source s, pdb_chain_source pcs, pdb_release pr1, pdb_release pr2, pdb_chain pc1, pdb_chain pc2, link_pdb l, scop_node n1 where pr1.pdb_entry_id=pr2.pdb_entry_id and pc2.pdb_release_id=pr2.id and pc2.id=pcs.pdb_chain_id and pcs.pdb_source_id=s.id and pc1.pdb_release_id=pr1.id and l.pdb_chain_id=pc1.id and l.node_id=n1.id and n1.parent_node_id="+oldParentID+" and s.ncbi_taxid="+pdbTaxid+" limit 1");
                if (rs.next()) {
                    sameSpecies = true;
                    if (debug)
                        System.out.println("Species: found same species 3");
                }
                else {
                    if (debug)
                        System.out.println("Species: NOT found same species 3");
                }
                rs.close();
            }
        }
        if (sameSpecies) {
            if (debug)
                System.out.println("Species: assigning same species");
            oldParentSunid = LocalSQL.getSunid(oldParentID);
            if (oldParentSunid == -1)
                throw new Exception("Error finding old sunid for node "+hitNode);
            newParentID = LocalSQL.lookupNodeBySunid(oldParentSunid,
                                                     scopMaxReleaseID);
            if (newParentID == 0)
                throw new Exception("Error finding new sunid for node "+hitNode);
            rs = stmt.executeQuery("select species_id from link_species where node_id="+newParentID);
            if (rs.next())
                speciesID = rs.getInt(1);
            rs.close();
        }
        else {
            if (debug)
                System.out.println("Species: assigning automated species");
            // assign to automated species
            if (pdbSpecies != null) {
                if (debug)
                    System.out.println("Species: trying to guess species based on PDB");
		
                // cut to first 2 words, assign case
                String[] s = pdbSpecies.split(" ");
                if (s.length < 2) {
                    pdbSpecies = null;
                    pdbTaxid = 0;
                }
                else if (pdbSpecies.toLowerCase().indexOf("virus") > -1) {
                    pdbSpecies = Character.toUpperCase(pdbSpecies.charAt(0))+
                        pdbSpecies.substring(1).toLowerCase();
                }
                else if ((s[1].charAt(0)=='(') &&
                         (s[1].charAt(s[1].length()-1)==')') &&
                         (s.length > 2)) {
                    // cases like Genus (OldGenus) species
                    pdbSpecies = Character.toUpperCase(s[0].charAt(0))+
                        s[0].substring(1).toLowerCase()+" ("+
                        Character.toUpperCase(s[1].charAt(1))+
                        s[1].substring(2).toLowerCase()+" "+
                        s[2].toLowerCase();
                }
                else {
                    pdbSpecies = Character.toUpperCase(s[0].charAt(0))+
                        s[0].substring(1).toLowerCase()+" "+
                        s[1].toLowerCase();
                }

                if (debug)
                    System.out.println("Species: guessed "+pdbSpecies);
            }
            String spDescription = "automated matches";
            if (pdbSpecies != null) {
                spDescription = pdbSpecies;
                if (pdbTaxid > 0)
                    spDescription += " [TaxId: "+pdbTaxid+"]";
                spDescription = StringUtil.replace(spDescription,"\"","\\\"");
            }
            rs = stmt.executeQuery("select id from scop_node where parent_node_id="+newParentID+" and description=\""+spDescription+"\" and sccs=\""+newSCCS+"\"");
            if (rs.next()) {
                newParentID = rs.getInt(1);
                rs.close();
            }
            else {
                rs.close();

                // try to look it up by scientific name and taxid
                if (pdbSpecies != null) {
                    int sn = 0;
                    int sp = 0;
                    if (pdbTaxid > 0)
                        rs = stmt.executeQuery("select n.id, s.id from scop_node n, link_species l, species s where n.id=l.node_id and l.species_id=s.id and s.scientific_name=\""+pdbSpecies+"\" and s.ncbi_taxid="+pdbTaxid+" and n.parent_node_id="+newParentID);
                    else
                        rs = stmt.executeQuery("select n.id, s.id from scop_node n, link_species l, species s where n.id=l.node_id and l.species_id=s.id and s.scientific_name=\""+pdbSpecies+"\" and n.parent_node_id="+newParentID);
                    if (rs.next()) {
                        sn = rs.getInt(1);
                        sp = rs.getInt(2);
                    }
                    if (rs.next()) {
                        // must be only one
                        sn = 0;
                        sp = 0;
                    }
                    if (sn > 0) {
                        newParentID = sn;
                        speciesID = sp;
                        if (debug)
                            System.out.println("found species level under protein");
                    }
                    rs.close();
                }

                if (!debug && (speciesID==0)) {
                    newParentID = LocalSQL.createNode((assignSunids ? LocalSQL.getNextSunid() : 0),
                                                      newSCCS,
                                                      null,
                                                      spDescription,
                                                      7,
                                                      newParentID,
                                                      scopMaxReleaseID,
                                                      annotationMethod);

                    speciesID = MakeSpecies.processNode(newParentID,
                                                        spDescription);

                    rv.add(new Integer(newParentID));
                }
            }
        }

        // domain level
        if (!debug) {
            // assign sid based on description
            String newSid = StableSid.assignNewSid(description);
	    
            int nodeID = LocalSQL.createNode((assignSunids ? LocalSQL.getNextSunid() : 0),
                                             newSCCS,
                                             newSid,
                                             description,
                                             8,
                                             newParentID,
                                             scopMaxReleaseID,
                                             annotationMethod);

            stmt.executeUpdate("insert into scop_comment values(null, " +
                               nodeID +
                               ", \"automated match to " + hitSid + "\", 0)");

            stmt.executeUpdate("insert into link_pdb values("+
                               nodeID+
                               ", "+pdbChainID+")");

            if (speciesID != 0)
                MakeSpecies.linkPDBSpecies(speciesID);
	    
            rv.add(new Integer(nodeID));
        }

        if (rv.size()==0)
            rv = null;
	
        stmt.close();
        return rv;
    }

    /**
     * Get the set of asteroid IDs for the chain that were created using ExactSeqMatchAnnotator
     *
     * @param stmt
     * @param astralChainID
     * @param scopReleaseID
     * @param pfamReleaseID
     * @return
     * @throws SQLException
     */
    public static Vector<Integer> getExactSeqMatchAsteroidsIDs(Statement stmt, int astralChainID, int scopReleaseID, int pfamReleaseID) throws SQLException {
        /*
          Vector<Integer> asteroidsForChain = new Vector<Integer>();

          // query to get all asteroids that were generated by the ExactSeqMatch
          String exactSeqMatchRegEx = "%" + ASTEROIDS.Annotation.sourceToString(ASTEROIDS.Annotation.Source.SCOPSEQMATCH) + "%";
          String queryExactSeqMatch = "select a.id from asteroid a where a.header like \"" + exactSeqMatchRegEx + "\" and a.scop_release_id=" + scopReleaseID + " and a.pfam_release_id=" + pfamReleaseID + " and a.chain_id=" + astralChainID;

          ResultSet rs = stmt.executeQuery(queryExactSeqMatch);
          while (rs.next()) {
          int asteroidID = rs.getInt(1);
          asteroidsForChain.add(new Integer(asteroidID));
          }
          rs.close();
          return asteroidsForChain;
        */
        return getAsteroidIDs(stmt, astralChainID, scopReleaseID, pfamReleaseID, ExactSequenceMatchChainAnnotator.getSidPrefix());
    }

    /**
     * Get the set of IDs for original-style ASTEROID domains for the chain that were created using blast
     * These are those where the sid begins with "u"
     *
     * @param stmt
     * @param astralChainID
     * @param scopReleaseID
     * @param pfamReleaseID
     * @return
     * @throws SQLException
     */
    public static Vector<Integer> getOriginalBlastAsteroidsIDs(Statement stmt, int astralChainID, int scopReleaseID, int pfamReleaseID) throws SQLException {
        Vector<Integer> asteroidsForChain = new Vector<Integer>();
        String queryBlast = "select a.id from asteroid a, astral_seq_blast b where a.blast_hit_id=b.id and a.scop_release_id=" + scopReleaseID + " and a.pfam_release_id=" + pfamReleaseID + " and a.chain_id=" + astralChainID + " and a.sid like \"u%\" order by sid asc" ;
        if (asteroidsForChain.isEmpty()) {
            ResultSet rs = stmt.executeQuery(queryBlast);
            while (rs.next()) {
                int asteroidID = rs.getInt(1);
                asteroidsForChain.add(new Integer(asteroidID));
            }
            rs.close();
        }
        return asteroidsForChain;
    }

    /**
     * @param stmt
     * @param astralChainID
     * @param scopReleaseID
     * @param pfamReleaseID
     * @param sidPrefix the prefix of the sid, for example "u" or "v" or "w"
     * @return
     * @throws SQLException
     */
    public static Vector<Integer> getAsteroidIDs(Statement stmt, int astralChainID, int scopReleaseID, int pfamReleaseID, String sidPrefix) throws SQLException {
        Vector<Integer> asteroidsForChain = new Vector<Integer>();
        String query = "select a.id from asteroid a where a.sid like \"" + sidPrefix + "%\" and a.scop_release_id=" + scopReleaseID + " and a.pfam_release_id=" + pfamReleaseID + " and a.chain_id=" + astralChainID + " order by a.sid asc";
        if (asteroidsForChain.isEmpty()) {
            ResultSet rs = stmt.executeQuery(query);
            while (rs.next()) {
                int asteroidID = rs.getInt(1);
                asteroidsForChain.add(new Integer(asteroidID));
            }
            rs.close();
        }
        return asteroidsForChain;
    }

    /**
       Expands a set of ASTEROIDS for a chain to near the ends of
       the chain, changing the descriptions.
       (first to the beginning, last to the end).  Set must be already
       sorted by position on the chain (by sid, in the case of original
       ASTEROIDS)
    */
    public static void expandToNearEnds(Statement stmt,
                                        int astralChainID,  // astral chain
                                        Vector<Integer> asteroids) throws Exception {

        ResultSet rs = stmt.executeQuery("select r.line from raf r, astral_chain ac where ac.id="+astralChainID+" and ac.raf_id=r.id");
        rs.next();
        String rafLine = rs.getString(1);
        rs.close();

        Integer asteroidID = asteroids.get(0);
        rs = stmt.executeQuery("select description from asteroid where id = "+asteroidID);
        rs.next();
        String description = rs.getString(1);
        rs.close();

        // turn description into Annotation, and extend 1st region
        ASTEROIDS.Annotation a = new ASTEROIDS.Annotation();
        a.parseHeaderRegions(description,
                             rafLine);
        a.regions.get(0).extendToNearEnd(rafLine,
                                         false);
        String oldDescription = description;
        description = a.getHeaderRegions(rafLine);
        if (!oldDescription.equals(description)) {
            System.out.println("  extending '"+oldDescription+"' to '"+description+"'");
            stmt.executeUpdate("update asteroid set description = \""+description+"\" where id="+asteroidID);
        }

        asteroidID = asteroids.get(asteroids.size()-1);
        rs = stmt.executeQuery("select description from asteroid where id = "+asteroidID);
        rs.next();
        description = rs.getString(1);
        rs.close();
	
        a = new ASTEROIDS.Annotation();
        a.parseHeaderRegions(description,
                             rafLine);
        a.regions.get(a.regions.size() - 1).extendToNearEnd(rafLine,
                                                            true);
        oldDescription = description;
        description = a.getHeaderRegions(rafLine);
        if (!oldDescription.equals(description)) {
            System.out.println("  extending '"+oldDescription+"' to '"+description+"'");
            stmt.executeUpdate("update asteroid set description = \""+description+"\" where id="+asteroidID);
        }
    }

    /**
       Parallel processing of ASTEROIDS.

       Works for both weekly update of existing releases, and
       for building new rleases.

       process a group of ASTEROIDS belonging to one ASTRAL chain
       Will first look for ASTEROIDS generated by ExactSequenceMatchChainAnnotator
       Then look for ASTEROIDS generated by BLAST

       if there are non-automated classifications from the same
       chain, ignore the ASTEROIDS

       if there are only automated classifications from the same
       chain, try to promote the ASTEROIDS.  If any promote, delete
       all the prior automated classifications (but if none promote,
       keep the prior classifications).

       if any promote, and it's a weekly update, do all the following
       stuff (like making seqs, thumbnails)

       if filter level is -1, this is a "manually OK'ed set" and
       the original ASTEROIDS will be processed internally with filter level 0.
    */
    final public static void processChain(int astralChainID,
                                          int pfamReleaseID,
                                          int scopReleaseID,
                                          int filterLevel) throws Exception {
        Statement stmt = LocalSQL.createStatement();
        ResultSet rs;

        boolean isWeeklyUpdate = false;
        int latestPublicSCOPRelease = LocalSQL.getLatestSCOPRelease(true);
        int latestSCOPRelease = LocalSQL.getLatestSCOPRelease(false);
        if ((latestSCOPRelease==latestPublicSCOPRelease) &&
            (scopReleaseID==latestSCOPRelease))
            isWeeklyUpdate = true;

        // collect ASTEROIDS.
        System.out.println("looking for ASTEROIDS from chain "+astralChainID);
        Vector<Integer> asteroidsForChain = new Vector<Integer>();
        int filterLevel2 = filterLevel; // actual filter level to use.
        int annotationMethod = 3;

        if (filterLevel != -1) {
            // First, try to get the asteroid IDs from the most precise method, ExactSequenceMatchChainAnnotator
            // System.out.println("looking for exact seq match");
            asteroidsForChain = getAsteroidIDs(stmt, astralChainID, scopReleaseID, pfamReleaseID, ExactSequenceMatchChainAnnotator.getSidPrefix());
            filterLevel2 = 32; // by default, just apply low-res filter
            annotationMethod = 4;

            // Second, try to get the asteroid IDs from BlastAnnotator
            if (asteroidsForChain.isEmpty()) {
                // System.out.println("looking for blast multi-chain");
                asteroidsForChain = getAsteroidIDs(stmt, astralChainID, scopReleaseID, pfamReleaseID, BlastAnnotator.getSidPrefix());
                filterLevel2 = 32; // just apply low-res filter for BLAST hits
                annotationMethod = 5;
            }
        }
        // Third, try to get original asteroids
        if (asteroidsForChain.isEmpty()) {
            // System.out.println("looking for original ASTEROIDS");
            asteroidsForChain = getOriginalBlastAsteroidsIDs(stmt, astralChainID, scopReleaseID, pfamReleaseID);
            if (filterLevel == -1) {
                filterLevel2 = 0;
                annotationMethod = 6;
                expandToNearEnds(stmt,
                                 astralChainID,
                                 asteroidsForChain);
            }
            else {
                filterLevel2 = filterLevel; // apply specified filter
                annotationMethod = 3;
            }
        }
        if (asteroidsForChain.isEmpty()) {
            // System.out.println("no ASTEROIDS found");
            stmt.close();
            return;
        }

        Vector<Integer> newIDs = processSet(astralChainID,
                                            asteroidsForChain,
                                            filterLevel2,
                                            isWeeklyUpdate,
                                            annotationMethod);
        if (newIDs == null) {
            stmt.close();
            return;
        }

        // do the following only if a weekly update
        if (!isWeeklyUpdate) {
            stmt.close();
            return;
        }

        // find pdb chain corresponding to this astral chain
        rs = stmt.executeQuery("select r.pdb_chain_id from raf r, astral_chain ac where ac.id="+astralChainID+" and ac.raf_id=r.id");
        rs.next();
        int pdbChainID = rs.getInt(1);
        rs.close();
        rs = stmt.executeQuery("select r.pdb_entry_id from pdb_release r, pdb_chain c where c.id="+pdbChainID+" and c.pdb_release_id=r.id");
        rs.next();
        int pdbEntryID = rs.getInt(1);
        rs.close();
	
        // freeze RAF, if not frozen, and make new chain seqs for it
        int rafID = LocalSQL.findRAF(pdbChainID, scopReleaseID);
        if (rafID==0) {
            rafID = FreezeRAF.addRAF(pdbChainID, scopReleaseID);
            MakeChainSeq.makeChainSeq(rafID);
        }

        // split off tags from ATOM chain seq
        FindTags.startLiveChanges();
        rs = stmt.executeQuery("select ac.id from astral_chain ac, raf r where ac.source_id=1 and ac.raf_id="+rafID);
        rs.next();        
        HashSet<Integer> tagDomains = FindTags.splitTagDomains(rs.getInt(1));
        rs.close();
        // assign sunids to tag domains
        for (Integer newID : tagDomains) {
            int nodeID = newID.intValue();
            stmt.executeUpdate("update scop_node set sunid="+LocalSQL.getNextSunid()+" where id="+nodeID);
        }
        // add tag domains to set for further processing
        newIDs.addAll(tagDomains);

        // do things on each newly promoted node:
        for (Integer newID : newIDs) {
            int nodeID = newID.intValue();
	    
            rs = stmt.executeQuery("select level_id from scop_node where id="+nodeID);
            rs.next();
            int levelID = rs.getInt(1);
            rs.close();
	    	    
            if (levelID==8) {
                // autogenerate comments
                MakeAutoComments.makeComments(nodeID);

                // make ASTRAL domains
                MakeDomainSeq.makeDomainSeqs(nodeID,false);

                // make PDB-style files
                rs = stmt.executeQuery("select d.id from astral_domain d, scop_node n, astral_seq s where d.seq_id=s.id and d.node_id=n.id and length(s.seq) > 0 and d.source_id=2 and (d.style_id=1 or d.style_id=3) and n.id="+nodeID);
                while (rs.next()) {
                    int domainID = rs.getInt(1);
                    MakePDBStyle.makePDBStyle(domainID);
                }
                rs.close();

                // make thumbnail
                MakeThumbnails.makeThumbnail(nodeID,true);

                // promote thumbnail to parents,
                // fill in representative subset data
                // merges duplicate nodes that can be created
                // due to race condition
                if (newIDs.size() > 1) {
                    for (Integer newID2 : newIDs) {
                        if (LocalSQL.isAncestor(newID2.intValue(),
                                                newID.intValue())) {
                            // check for duplicate descriptions
                            rs = stmt.executeQuery("select n1.id from scop_node n1, scop_node n2 where n1.release_id=n2.release_id and n1.id<n2.id and n1.level_id=n2.level_id and n1.parent_node_id=n2.parent_node_id and n1.description=n2.description and n2.id="+newID2+" order by n1.id asc limit 1");
                            if (rs.next()) {
                                int mergeID = rs.getInt(1);
                                rs.close();
                                ManualEdit.mergeNode(newID2, mergeID, false);
                            }
                            else {
                                // if we merged, there is already a rep for other clade.
                                // if not, we might need to make one
                                rs.close();
                                rs = stmt.executeQuery("select rep_node_id from scop_subset_level where level_node_id="+newID2);
                                if (rs.next())
                                    rs.close();
                                else {
                                    // only make rep if not already one
                                    rs.close();
                                    stmt.executeUpdate("insert into scop_subset_level values ("+newID+", "+newID2+")");
                                    MakeThumbnails.copyRepThumbnails(nodeID, newID2.intValue());
                                }
                            }
                        }
                    }
                }

                // SPACI
                FreezeSPACI.addSPACI(pdbEntryID,
                                     scopReleaseID,
                                     true);
            }

            // add to index
            MakeIndex.indexNode(nodeID);

            // add to history
            stmt.executeUpdate("insert into scop_history values (null, "+nodeID+", null, "+scopReleaseID+", 12, now())");
        }
        stmt.close();
    }
    
    /**
       process a set of ASTEROIDS belonging to one ASTRAL chain.

       if there are non-automated classifications from the same
       chain, ignore the ASTEROIDS

       if there are only automated classifications from the same
       chain, try to promote the ASTEROIDS.  If any promote, delete
       all the prior automated classifications iff isWeeklyUpdate
       is false (and if none promoted, keep any prior classifications)

       Returns set of new node ids if any were promoted (otherwise null).
    */
    final public static Vector<Integer> processSet(int astralChainID,
                                                   Vector<Integer> asteroidIDs,
                                                   int filterLevel,
                                                   boolean isWeeklyUpdate,
                                                   int annotationMethod) throws Exception {
        Statement stmt = LocalSQL.createStatement();

        ResultSet rs = stmt.executeQuery("select max(id) from scop_release");
        rs.next();
        int scopMaxReleaseID = rs.getInt(1);
        rs.close();

        // look up ASTRAL chain in RAF for current release
        String sid = null;

        rs = stmt.executeQuery("select sid from astral_chain where id="+astralChainID);
        if (rs.next())
            sid = rs.getString(1);

        if (sid==null) {
            System.out.println("error: ASTRAL chain "+astralChainID+" missing");
            stmt.close();
            return null;
        }

        int pdbChainID = 0;
        if (!isWeeklyUpdate) {
            String rafOld = null;
            String rafNew = null;
            // find the newest PDB chain that matches this ASTRAL
            // chain, prior to the freeze date of the latest SCOP release
            rs = stmt.executeQuery("select pc2.id, r1.line, r2.line, pr2.replaced_by from pdb_release pr1, pdb_release pr2, pdb_chain pc1, pdb_chain pc2, raf r1, raf r2, scop_release s, pdb_local l, astral_chain ac, pdb_entry e where s.id="+scopMaxReleaseID+" and pr2.file_date <= s.freeze_date and pr2.revision_date <= s.freeze_date and l.snapshot_date <= s.freeze_date and pr1.pdb_entry_id=e.id and pr2.pdb_entry_id=e.id and (e.obsolete_date is null or e.obsolete_date > s.freeze_date) and l.pdb_release_id=pr2.id and l.xml_path is not null and pc2.pdb_release_id=pr2.id and pc1.pdb_release_id=pr1.id and pc1.chain=pc2.chain and r1.pdb_chain_id=pc1.id and r2.pdb_chain_id=pc2.id and ac.raf_id=r1.id and ac.id="+astralChainID+" order by l.snapshot_date desc limit 1");
            if (rs.next()) {
                pdbChainID = rs.getInt(1);
                rafOld = rs.getString(2);
                rafNew = rs.getString(3);
                int replacedBy = rs.getInt(4);
                if ((replacedBy>0) && (!rs.wasNull())) {
                    rs.close();
                    // if release was replaced before the freeze date, reject
                    rs = stmt.executeQuery("select pr.id from pdb_release pr, scop_release s, pdb_local l where s.id="+scopMaxReleaseID+" and pr.file_date <= s.freeze_date and pr.revision_date <= s.freeze_date and l.snapshot_date <= s.freeze_date and l.pdb_release_id=pr.id and l.xml_path is not null and pr.id="+replacedBy);
                    if (rs.next())
                        pdbChainID = 0;
                }
            }
            rs.close();

            if (pdbChainID==0) {
                System.out.println("not promoting domains from "+sid+"; chain not in frozen PDB");
                stmt.close();
                return null;
            }

            if (!rafOld.substring(38).equals(rafNew.substring(38))) {
                System.out.println("not promoting domains from "+sid+"; chain changed in frozen PDB");
                stmt.close();
                return null;
            }
        }
        else {
            // find any PDB chain in SCOP that matches this ASTRAL chain
            rs = stmt.executeQuery("select c1.id from link_pdb l, scop_node n, pdb_chain c1, pdb_chain c2, pdb_release r1, pdb_release r2, raf r, astral_chain ac where n.release_id="+scopMaxReleaseID+" and n.level_id=8 and n.id=l.node_id and l.pdb_chain_id=c1.id and c1.pdb_release_id=r1.id and r1.pdb_entry_id=r2.pdb_entry_id and c2.pdb_release_id=r2.id and c2.id=r.pdb_chain_id and ac.raf_id=r.id and ac.id="+astralChainID+" and c1.chain=c2.chain");
            if (rs.next())
                pdbChainID = rs.getInt(1);
            else {
                rs.close();
                // find PDB chain (not in SCOP) that matches this ASTRAL chain
                rs = stmt.executeQuery("select r.pdb_chain_id from raf r, astral_chain ac where ac.id="+astralChainID+" and ac.raf_id=r.id");
                if (rs.next())
                    pdbChainID = rs.getInt(1);
            }
            rs.close();
        }

        // is PDB entry obsolete?
        rs = stmt.executeQuery("select e.id from pdb_entry e, pdb_release r, pdb_chain c where c.pdb_release_id=r.id and r.pdb_entry_id=e.id and e.obsolete_date is not null and c.id="+pdbChainID);
        if (rs.next()) {
            System.out.println("not promoting domains from "+sid+"; PDB entry is obsolete");
            rs.close();
            stmt.close();
            return null;
        }
        rs.close();

        // is PDB release obsolete?
        rs = stmt.executeQuery("select r.id from pdb_release r, pdb_chain c where c.pdb_release_id=r.id and r.replaced_by is not null and c.id="+pdbChainID);
        if (rs.next()) {
            System.out.println("not promoting domains from "+sid+"; PDB release is obsolete");
            rs.close();
            stmt.close();
            return null;
        }
        rs.close();
	
        // look for domains from this chain already in SCOP
        Vector<Integer> matches = new Vector<Integer>();
        rs = stmt.executeQuery("select n.id from link_pdb l, scop_node n where n.release_id="+scopMaxReleaseID+" and n.level_id=8 and n.id=l.node_id and l.pdb_chain_id="+pdbChainID);
        while (rs.next())
            matches.add(new Integer(rs.getInt(1)));
        rs.close();

        // look for ones that are old-style automated matches
        boolean hasCuratedDomains = false;
        for (Integer nodeID : matches) {
            rs = stmt.executeQuery("select id from scop_comment where description like \"automatically matched to %\" and node_id="+nodeID);
            if (!rs.next())
                hasCuratedDomains = true;
            rs.close();
        }

        if (hasCuratedDomains) {
            System.out.println("not promoting domains from "+sid+"; curated domains present");
            stmt.close();
            return null;
        }

        if (isWeeklyUpdate && (matches.size() > 0)) {
            System.out.println("not promoting domains from "+sid+"; can't delete automated domains in weekly update");
            stmt.close();
            return null;
        }

        // try to avoid race condition by letting upper case chain
        // try to promote before lower case chain
        rs = stmt.executeQuery("select ac.id from astral_chain ac, pdb_chain pc1, pdb_chain pc2, raf r where pc2.id="+pdbChainID+" and pc1.pdb_release_id=pc2.pdb_release_id and pc1.chain=upper(pc2.chain) and pc2.chain=lower(pc1.chain) and pc1.id != pc2.id and ac.raf_id=r.id and r.pdb_chain_id=pc1.id");
        while (rs.next()) {
            int otherAstralChainID = rs.getInt(1);
            WaitForJobs.waitFor(21,otherAstralChainID,1);
        }

        // look for domains from chain with same letter, different case
        // potential race condition, which I tried to eliminate above
        rs = stmt.executeQuery("select n1.id from scop_node n1, link_pdb l1, pdb_chain pc1, pdb_chain pc2, pdb_release pr1, pdb_release pr2 where n1.release_id="+scopMaxReleaseID+" and l1.node_id=n1.id and l1.pdb_chain_id=pc1.id and pc1.pdb_release_id=pr1.id and pc2.pdb_release_id=pr2.id and pr1.pdb_entry_id=pr2.pdb_entry_id and pc1.chain!=pc2.chain and upper(pc1.chain)=upper(pc2.chain) and n1.level_id=8 and pc2.id="+pdbChainID);
        if (rs.next()) {
            System.out.println("not promoting domains from "+sid+"; SCOP sids not yet case sensitive");
            rs.close();
            stmt.close();
            return null;
        }
        rs.close();

        System.out.println("working on ASTEROIDS from "+sid);

        Vector<Integer> newIDs = new Vector<Integer>();
        for (Integer asteroidID : asteroidIDs) {
            System.out.println(" trying ASTEROID "+asteroidID+" "+pdbChainID+" "+filterLevel);
            Vector<Integer> promoted = promoteASTEROID(asteroidID.intValue(),
                                                       pdbChainID,
                                                       filterLevel,
                                                       false,
                                                       isWeeklyUpdate,
                                                       annotationMethod);
            if ((promoted != null) && (promoted.size() > 0))
                newIDs.addAll(promoted);
        }

        if (newIDs.size()==0)
            newIDs = null;

        if (newIDs != null) {
            System.out.println("promoted ASTEROIDS from "+sid);

            // delete old automated matches, if any
            if (matches.size() > 0)
                System.out.println("deleting old domains from "+sid);
            for (Integer nodeID : matches)
                ManualEdit.deleteNode(nodeID,false);
        }

        stmt.close();
        return newIDs;
    }

    final public static void main(String argv[]) {
        try {
            LocalSQL.connectRW();
            Statement stmt = LocalSQL.createStatement();
            ResultSet rs;

            // rs = stmt.executeQuery("select chain_id from asteroid where sid like 'u4j70%'");
            // while (rs.next()) {
            // doWeeklyUpdate(rs.getInt(1), 55, 13, 127);
            // }

            /*
              processChain(698018, 55, 13, 127); // should fail due to existing PDB
              processChain(594634, 55, 13, 127); // should fail due to obs pdb
              processChain(944080, 56, 13, 127); // should fail due to already promoted
              processChain(944082, 56, 13, 127); // should fail due to already promoted
              processChain(786852, 56, 13, 127);
              processChain(786854, 56, 13, 127);
              processChain(86856, 56, 13, 127);
              processChain(1052580, 56, 13, 127);
              processChain(715034, 56, 13, 127);
              processChain(1456096, 56, 13, 127);
              MakeASTEROIDS.makeASTEROIDS(2607686, 56, 14);
              MakeASTEROIDS.makeASTEROIDS(2607690, 56, 14);
              processChain(2607686, 56, 14, 127);
              processChain(2607690, 56, 14, 127);
              System.exit(0);
            */

            // debug a single promotion attempt
            if (argv[0].startsWith("C")) {
                int astralChainID = StringUtil.atoi(argv[0],1);
                if ((argv.length > 1) && (argv[1].equals("--ok")))
                    processChain(astralChainID, 57, 18, -1);
                else
                    processChain(astralChainID, 57, 18, 127);
                System.exit(0);
            }

            // filtering must be explicit
            int filterLevel = StringUtil.atoi(argv[0]);
            System.out.println("Promoting ASTEROIDS using filter level "+filterLevel);

            // optionally limit to certain releases:
            int pfamReleaseID = LocalSQL.lookupPfamRelease(argv[1]);
            if (pfamReleaseID==0)
                throw new Exception("Can't determine Pfam version from "+argv[1]);
            System.out.println("Promoting ASTEROIDS from Pfam "+argv[1]);

            int scopReleaseID = LocalSQL.lookupSCOPRelease(argv[2]);
            if (scopReleaseID == 0)
                throw new Exception("Can't determine SCOP version from " + argv[1]);

            // group ASTEROIDS by chain based on BLAST hits:
            String query = "select distinct(a.chain_id) from asteroid a where ";//, astral_seq_blast b where a.blast_hit_id=b.id and "
            query += "a.scop_release_id=" + scopReleaseID + " and a.pfam_release_id=" + pfamReleaseID;
            System.out.println("Promoting ASTEROIDS from SCOP " + argv[2]);

            rs = stmt.executeQuery(query);
            while (rs.next()) {
                int astralChainID = rs.getInt(1);

                LocalSQL.newJob(21,
                                astralChainID,
                                pfamReleaseID+" "+scopReleaseID+ " "+filterLevel);
            }
            rs.close();
            stmt.close();
        }
        catch (Exception e) {
            System.out.println("Exception: "+e.getMessage());
            e.printStackTrace();
        }
    }
}
